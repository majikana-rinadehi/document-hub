name: Publish to Zenn

on:
  workflow_call:
    inputs:
      entity-id:
        required: true
        type: string
        description: The Notion entity ID to process
  workflow_dispatch:
    inputs:
      entity-id:
        description: "Notion entity ID to process"
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  publish:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Fetch latest changes and create branch for PR
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          # Fetch latest changes from main
          git fetch origin main
          git checkout main
          git pull origin main
          # Create new branch from latest main
          BRANCH_NAME="publish-zenn-${{ inputs.entity-id }}-$(date +%Y%m%d%H%M%S)"
          git checkout -b $BRANCH_NAME
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

      - name: Check platforms and copy article
        id: check-platforms
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const entityId = '${{ inputs.entity-id }}';
            const outputDir = 'output';
            const zennArticlesDir = 'articles';
            const zennImagesDir = 'images';

            // Check if metadata exists
            const metadataPath = path.join(outputDir, `${entityId}.json`);

            if (!fs.existsSync(metadataPath)) {
              console.log(`Metadata ${entityId}.json not found in output directory`);
              console.log('âœ… Workflow completed successfully (no metadata to process)');
              core.setOutput('should-continue', 'false');
              return;
            }

            // Read metadata
            const metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf8'));

            // Check if Zenn is in platforms - following the spec: metadata.properties.Platforms.multi_select[].name
            const platforms = metadata.properties?.Platforms?.multi_select || [];
            const hasZenn = platforms.some(p => p.name === 'Zenn');

            if (!hasZenn) {
              console.log('Zenn is not included in platforms metadata');
              console.log('Platforms found:', platforms.map(p => p.name).join(', ') || 'none');
              console.log('âœ… Workflow completed successfully (Zenn not in platforms)');
              core.setOutput('should-continue', 'false');
              return;
            }

            console.log('âœ… Zenn is included in platforms, processing article...');

            // Check if article exists
            const articlePath = path.join(outputDir, `${entityId}.md`);

            if (!fs.existsSync(articlePath)) {
              console.log(`Article ${entityId}.md not found in output directory`);
              console.log('âœ… Workflow completed successfully (no article to process)');
              core.setOutput('should-continue', 'false');
              return;
            }

            const title = metadata.title || metadata.properties?.Title?.title?.[0]?.plain_text || 'Untitled';
            const status = metadata.properties?.Status?.status?.name || 'Draft';
            const published = status === 'Published' ? 'true' : 'false';

            // Check if existing Zenn article exists and extract emoji from frontmatter
            const existingZennArticlePath = path.join(zennArticlesDir, `${entityId}.md`);
            
            // Extract emoji from existing article if it exists
            const extractExistingEmoji = () => {
              if (!fs.existsSync(existingZennArticlePath)) {
                return null;
              }
              const existingContent = fs.readFileSync(existingZennArticlePath, 'utf8');
              const emojiMatch = existingContent.match(/^---[\s\S]*?emoji:\s*"([^"]+)"[\s\S]*?---/);
              return emojiMatch && emojiMatch[1] ? emojiMatch[1] : null;
            };
            
            // Generate random positive emoji
            const generateRandomEmoji = () => {
              const emojis = ['ğŸš€', 'âœ¨', 'ğŸ‰', 'ğŸŒŸ', 'ğŸ’¡', 'ğŸ”¥', 'âš¡', 'ğŸ¯', 'ğŸ†', 'ğŸ’ª', 'ğŸŒˆ', 'â˜€ï¸', 'ğŸŒ¸', 'ğŸ¨', 'ğŸ­', 'ğŸª', 'ğŸ¡', 'ğŸ¢', 'ğŸ '];
              return emojis[Math.floor(Math.random() * emojis.length)];
            };
            
            // Use existing emoji if available, otherwise generate a new one
            const existingEmoji = extractExistingEmoji();
            const emoji = existingEmoji || generateRandomEmoji();
            
            if (existingEmoji) {
              console.log(`âœ… Found existing emoji: ${emoji}`);
            } else {
              console.log(`âœ… Generated new emoji: ${emoji}`);
            }

            // Read original content
            const originalContent = fs.readFileSync(articlePath, 'utf8');

            // Create Zenn article with frontmatter
            const frontmatter = `---
            title: "${title}"
            emoji: "${emoji}"
            type: "tech"
            topics: []
            published: ${published}
            ---

            `;

            // Ensure directories exist
            if (!fs.existsSync(zennArticlesDir)) {
              fs.mkdirSync(zennArticlesDir, { recursive: true });
            }
            if (!fs.existsSync(zennImagesDir)) {
              fs.mkdirSync(zennImagesDir, { recursive: true });
            }

            // Write article with frontmatter
            const zennArticlePath = path.join(zennArticlesDir, `${entityId}.md`);
            fs.writeFileSync(zennArticlePath, frontmatter + originalContent);

            console.log(`âœ… Article copied to ${zennArticlePath}`);

            // Copy images referenced in the markdown
            const imageRegex = /!\[.*?\]\((.*?)\)/g;
            let match;
            const copiedImages = [];

            while ((match = imageRegex.exec(originalContent)) !== null) {
              const imgPath = match[1];
              
              // Skip if it's an external URL
              if (imgPath.startsWith('http://') || imgPath.startsWith('https://')) {
                continue;
              }
              
              // Remove leading slash if present
              const cleanImgPath = imgPath.startsWith('/') ? imgPath.substring(1) : imgPath;
              
              // Try to find the image
              let sourceImagePath = null;
              if (fs.existsSync(path.join(outputDir, cleanImgPath))) {
                sourceImagePath = path.join(outputDir, cleanImgPath);
              } else if (fs.existsSync(cleanImgPath)) {
                sourceImagePath = cleanImgPath;
              }
              
              if (sourceImagePath) {
                const imageName = path.basename(cleanImgPath);
                const destImagePath = path.join(zennImagesDir, imageName);
                fs.copyFileSync(sourceImagePath, destImagePath);
                copiedImages.push(imageName);
                console.log(`âœ… Copied image: ${imageName}`);
              }
            }

            // Output summary
            console.log('\nğŸ“Š Summary:');
            console.log(`- Entity ID: ${entityId}`);
            console.log(`- Title: ${title}`);
            console.log(`- Status: ${status}`);
            console.log(`- Published: ${published}`);
            console.log(`- Emoji: ${emoji}`);
            console.log(`- Images copied: ${copiedImages.length}`);

            core.setOutput('should-continue', 'true');

      - name: Commit changes
        if: steps.check-platforms.outputs.should-continue == 'true'
        run: |
          git add articles/ images/
          git commit -m "feat: Publish article ${{ github.event.inputs.article_id }} to Zenn

          - Article ID: ${{ inputs.entity-id }}
          - Title: $(jq -r '.title // .properties.Title.title[0].plain_text // "Untitled"' "output/${{ inputs.entity-id }}.json")
          - Status: $(jq -r '.properties.Status.status.name // "Draft"' "output/${{ inputs.entity-id }}.json")"

      - name: Push branch
        if: steps.check-platforms.outputs.should-continue == 'true'
        run: |
          git push origin ${{ env.BRANCH_NAME }}

      - name: Generate token
        if: steps.check-platforms.outputs.should-continue == 'true'
        id: generate_token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Create Pull Request
        if: steps.check-platforms.outputs.should-continue == 'true'
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        with:
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');
            const path = require('path');

            const entityId = '${{ inputs.entity-id }}';
            const branchName = '${{ env.BRANCH_NAME }}';

            // Read metadata for PR details
            const metadataPath = path.join('output', `${entityId}.json`);
            const metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf8'));
            const title = metadata.title || metadata.properties?.Title?.title?.[0]?.plain_text || 'Untitled';
            const status = metadata.properties?.Status?.status?.name || 'Draft';

            // Add emoji for status
            const statusEmoji = status === 'Published' ? 'âœ…' : status === 'Preview' ? 'ğŸ‘€' : '';
            const statusDisplay = statusEmoji ? `${statusEmoji} ${status}` : status;

            // Create PR using gh CLI
            const prTitle = `ğŸ“ Publish to Zenn: ${title}`;
            const prBody = `## ğŸ“š Article Publication to Zenn

            ### Article Details
            - **ID**: \`${entityId}\`
            - **Title**: ${title}
            - **Status**: ${statusDisplay}
            - **Target Platform**: ğŸ“˜ Zenn

            ### Changes
            - âœ… Copied article from \`output/${entityId}.md\` to \`blog-platforms/zenn/articles/\`
            - âœ… Added Zenn frontmatter with metadata
            - âœ… Copied associated images (if any)

            ### Zenn Article Link
            - ğŸ”— [View on Zenn](https://zenn.dev/rudy/articles/${entityId})

            ---
            *This PR was automatically generated by the Publish to Zenn workflow*`;

            try {
              const result = execSync(`gh pr create --title "${prTitle}" --body "${prBody}" --base main --head ${branchName}`, {
                encoding: 'utf8',
                env: { ...process.env, GH_TOKEN: process.env.GH_TOKEN }
              });
              
              console.log('âœ… Pull request created successfully');
              console.log(result);
            } catch (error) {
              console.error('Failed to create PR:', error.message);
              throw error;
            }
